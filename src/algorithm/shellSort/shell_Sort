
Shell Sort는 Donald Shell 에 의해 고안된 정렬 방법으로 Shell 이라는 이름이 붙었다. (우리가 아는 리눅스의 shell과는 관련 없다)

앞서 설명했듯 Insertion Sort(삽입 정렬)의 장점은 살리면서 단점은 줄인 방식이라고 했다.

삽입 정렬의 단점은 오름차순 기준으로 타겟 원소가 이전의 원소보다 작을경우 이전 원소들 모두 교환(swap)을 한다는 것이다.
 그럼 이 과정을 줄인다면 어떨까?
즉, 이전의 원소를 모두 비교, 교환하는 것이 아니라 일정 간격 주기로 띄엄띄엄 검사하면서 교환하여 타겟 원소의 위치를 대략적으로 잡아주는 것이다.
그리고 위와 같은 과정을 '간격을 줄여가면서' 정렬해나가다보면 정렬기준에 가까워지지 않겠는가? 그러면 삽입정렬의 장점인 거의 정렬 된 상태일 경우 정렬 속도가 빠르다는 이점 또한 가져갈 수 있다.

쉽게말해 정렬하고자 하는 원소가 10개가 있을 때 간격을 3으로 설정하여 간격이 4인 원소들끼리 삽입정렬을 하고 그 다음 간격을 2로 조정하여 2칸씩 떨어진 원소들끼리 삽입정렬을 하고,
최종적으로 간격이 1인 즉, 우리가 알고있는 기본적인 삽입정렬을 하는 것이다. 이러한 과정을 거치는 것이 바로 셸 정렬이라는 것이다.


셸 정렬은 데이터를 '비교'하면서 찾기 때문에 '비교 정렬'이며 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않기 때문에
'제자리 정렬(in-place sort)'이기도 하다.
 정확히는 데이터를 서로 교환하는 과정(swap)에서 임시 변수를 필요로 하나, 이는 충분히 무시할 만큼 적은 양이기 때문에 제자리 정렬로 보는 것이다.
 이는 선택정렬, 거품 정렬과도 같은 부분이다.

다만, 삽입정렬과는 다르게 일정 간격을 주기로 하여 비교 및 교환이 일어나기 때문에 구조상 안정정렬(Stable Sort)은 아니다.

셸 정렬의 장점 및 단점

[장점]
1. 멀리 있는 원소들끼리 빠르게 비교 및 교환이 이루어진다.
2. 삽입정렬(Insertion Sort), 거품정렬(Bubble Sort)에 비해 정렬 속도가 빠르다.

[단점]
1. 일반적인 삽입정렬에 비해 구현이 까다롭다.
2. gap sequence에 영향을 많이 받으며 적절한 시퀀스를 선택해야 한다.
3. 일정 간격을 두고 원소의 교환이 이루어지기 때문에 안정정렬이 아니다.

시간 복잡도에 대해 잠깐 언급하자면 가장 간단하게 답을 내릴 수 있다. "갭 시퀀스에 따라 달라진다."
왜냐하면, 결국 서브 리스트를 어떻게 분할해서 삽입정렬을 하느냐인데 간단히 구해지는 갭 시퀀스는 어떻게든 시간 복잡도를 구할 수 있다만,
 오늘처럼 일정한 규칙이 아닌 경험적으로 얻어낸 시퀀스나 복잡한 수식에 의해 얻어낸 시퀀스의 경우 그 분석이 매우 어렵다.

다만, 이상적으로 최상의 경우나 최악의 경우는 구할 수 있다.
최상의 경우는 이미 정렬 된 상태이면서, gap sequence가 현재 리스트의 크기를 2n 으로 나눌 수 있을 때다.
그러면 삽입정렬 과정에서 이전의 데이터를 한 번만 비교 한 뒤 더이상 비교하지 않기 때문에 사실상 리스트의 원소를 탐색하는 과정이 시간복잡도가 된다.

쉽게 생각해보면 리스트의 크기가 N일 때 이분탐색처럼 N/2 + N/4 + N/8 + ⋯ + 1 이다.
그러면 연산횟수가 x라고 할 때 N이 1일 경우 1에서 2를 x번 곱해야 한다. 즉, N = 1 × 2x 방정식이 나오고,
x를 구하기 위해 양변에 로그를 취해 log2N = xlog22 를 만들어 다시 풀면 logN = x 가 된다.

여기서 위 logN 는 특정 값에 다다르기 위한 x이고,
 이 과정을 정렬에서는 모든 원소가 한 번씩 해야하기 때문에 logN 이 N번 반복되므로 시간 복잡도는 O(NlogN) 이 된다는 정도다.


최악의 경우는 gap이 1이고 삽입정렬의 가장 단점이였던 '역순으로 된 리스트' 일 경우이므로.
 한 마디로 그냥 삽입 정렬과 똑같으면서 최악의 경우를 생각하면 된다. 당연 O(N2)의 시간 복잡도를 갖는다.

하지만 gap을 1로 사용하면 삽입정렬과 다를게 없기 때문에 일반적인 gap sequence에서는 이 또한 얘기가 달라진다.

정리하자면 일반적으로 시간복잡도는 구하기 매우 까다롭고 어려우며 갭 시퀀스에 따라 의존적이다.

